\documentclass{book}
\usepackage[margin=1in,footskip=0.25in]{geometry}
\usepackage{pgf, tikz}
\usepackage{amsmath}
\usepackage{centernot}
\usepackage{pgfplots}

\usetikzlibrary{arrows, automata}

\title{CDA3100-0001: Comp Org 1}
\author{Ahmet}

\begin{document}
	\noindent Computer Organization 1\\\\
	\emph{Types of Computers}
	\begin{enumerate}
		\item Personal Computers (PCs)
			\begin{itemize}
				\item Intended for a single user at a stationary location
				\item Notebooks and workstations
				\item Emphasize good performance to single users at low cost
			\end{itemize}
		\item Servers
			\begin{itemize}
				\item Accessed by other computers to provide computation and/or data
				\item Typically only accessed via a network
				\item Greater computing, storage, and I/O capacity
				\item Emphasis on performing well under large workloads with enhanced dependability
			\end{itemize}
		\item Embedded Computers
			\begin{itemize}
				\item \textbf{Most Prevalent type of computer/computer class}
				\item Computers contained in other devices
				\item Usually a small number of predetermined applications
				\item Emphasis on cost and low power 
			\end{itemize}
		\item Personal Mobile Device
			\begin{itemize}
				\item Battery-powered wireless devices with multimedia user interfaces
				\item Smart phones and tablets
				\item Reliance on touch screens
				\item Emphasis on cost and energy efficiency 
			\end{itemize}
		\item Large Cluster/Warehouse-Scale-Computers (WSCs)
			\begin{itemize}
				\item Large collections of servers connected by a network to act as a single powerful computer
				\item Scalability and availability handled through the network 
			\end{itemize}
	\end{enumerate}

	\noindent \emph{Eight Great Architecture Ideas}
	\begin{enumerate}
		  \item Design for Moore's Law
		  \item Abstraction
		  \item Make the common case fast
		  \item Parallelism
		  \item Pipelining
		  \item Prediction
		  \item Hierachy
  		\item Improve dependability via redundancy
	\end{enumerate}

	\noindent \emph{Steps for executing a program}
	\begin{enumerate}
  		\item Input device loads the machine code from the executable
  		\item The machine code is stored in memory
  		\item Processor fetches an instruction
  		\item Control decodes the instruction
  		\item Datapath executes the instruction
  		\item If application does not complete, then go to step 3
	\end{enumerate}
	\noindent \emph{\textbf{REMEMBER:}} When executing a program, you first decode the instructions for the control, and then execute the instructions.\\

	\noindent \emph{\textbf{REMEMBER:}} QTSpim is \textbf{not} a compiler, it is an \textbf{assembler.}\\

	\noindent \emph{Formulas to remember: }\\
	\begin{center}
		$$\text{Dies per Wafer} \approx \frac{\text{Wafer Area}}{\text{Die Area}}$$
		$$\text{Yield} = \frac{1}{(1 + (\text{Defects per area})(\frac{\text{Die Area}}{2}))^2} $$
		$$\text{Cost per Die} = \frac{\text{Wafer Cost}}{(\text{Die per Wafer}) * \text{yield}}$$
		
		$$ \text{When comparing performance between } \text{Computer}_x \text{ and } \text{Computer}_y:$$
		$$ \text{Performance} = \frac{1}{\text{Execution Time}}$$
		$$ \text{Performance}_x > \text{Performance}_y $$
		$$ \frac{1}{\text{Execution Time}_x} >  \frac{1}{\text{Execution Time}_y}$$
		$$ \text{Execution Time}_y  > \text{Execution Time}_x $$

		$$ \text{Finding CPU Time: } $$
		$$ \text{CPU Time} = \text{CPU Clock Cycles} * \text{CPU Clock Cycle Time} = \frac{\text{CPU Clock Cycles}}{\text{CPU clock rate}} $$
		$$ \text{CPI} = \frac{\text{CPU Clock Cycles}}{\text{Instruction Count}} $$
		$$ \text{CPU Time} = \text{Instruction Count} * \text{CPI} * \text{CPU Clock Cycles} $$ \\

		$$ \text{Relationship between clock rate and clock speed rotation:} $$
		$$ \text{clock rate} = \frac{1}{\text{clock speed}} $$
		$$ \text{clock speed} = \frac{1}{\text{clock rate}} $$

		$$ \text{Calculate Overall Speedup} $$
		$$ \text{execution time}_{new} = \text{execution time}_{old} * (1 - \text{fraction}_{enhanced} + \frac{\text{fraction}_{enhanced}}{\text{speedup}_{enhanced}}$$
		$$ \text{speedup}_{overall} = \frac{\text{execution time}_{old}}{\text{execution time}_{new}} = \frac{1}{(1 - \text{fraction}_{enhanced}) + \frac{\text{fraction}_{enhanced}}{\text{speedup}_{enhanced}}}$$
	\end{center}

	\noindent\emph{Terms to know: }
	\begin{enumerate}
		\item \textbf{Latency Response (execution time)}: The time between the start and completion of an event or task.
		\item \textbf{Bandwidth/Throughput}: The total amount of work done in a given period of time.
		\item \textbf{Clock cycles Per Instruction (CPI)}: Average number of clock cycles per instruction for a program or process
		\item \textbf{Amdahl's Law}: The performance improvement gained from using an enhanced component is limited by the portion improved.
	\end{enumerate}

	\noindent \emph{\textbf{REMEMBER:}} The memory access bottleneck is caused by fast execution time and slower memory access time. To solve this we use \textbf{3 layers of cache}\\

	\noindent \emph{Conversions: } \\
	$ 1 \text{ Kib} \text{ (Kibibyte) } = 2^{10} \text{ bytes or } 1024 \text{ bytes}$ \\
	$ 1 \text{ Kib } = 1024 \text{ bytes } = 1.024 \text{ KB} $ \\
	\emph{For memory: } $2^n$ can store $\{0, 1, ..., 2^{n - 1}\}$ bytes. \\

	\noindent \emph{Power Issues: }\\
	\noindent \textbf{Energy} is the capacity to change an object's state. Measured in joules.\\
	\indent One joule is equal to one Newton acting through one meter.\\
	\noindent \textbf{Power} is the energy amount used over a period of time, units are Watts.\\
		\indent Watts = $\frac{joules}{second}$
		$$ \text{Power} = \frac{\text{$\Delta$ Energy}}{\text{$\Delta$ Time}} $$
	\begin{enumerate}
		\item There is a need for energy efficient Processors becuase of the \textbf{major issue of \emph{heat}}.
		\item There are two main types of energy we are concerned about:
		\begin{enumerate}
			\item \textbf{Dynamic Energy:} The energy consumed by the switching from 0 to 1 or from 1 to 0.
			\item \textbf{Static Energy:} The energy consumed through current leakage
		\end{enumerate}
	\end{enumerate}
\end{document}