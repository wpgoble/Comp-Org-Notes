\documentclass{book}
\usepackage[margin=1in,footskip=0.25in]{geometry}
\usepackage{pgf, tikz}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{centernot}
\usepackage{pgfplots}

\usetikzlibrary{arrows, automata}

\title{CDA3100-0001: Comp Org 1}
\author{Ahmet}

\begin{document}
	\noindent Computer Organization 1\\\\
	\emph{Types of Computers}
	\begin{enumerate}
		\item Personal Computers (PCs)
			\begin{itemize}
				\item Intended for a single user at a stationary location
				\item Notebooks and workstations
				\item Emphasize good performance to single users at low cost
			\end{itemize}
		\item Servers
			\begin{itemize}
				\item Accessed by other computers to provide computation and/or data
				\item Typically only accessed via a network
				\item Greater computing, storage, and I/O capacity
				\item Emphasis on performing well under large workloads with enhanced dependability
			\end{itemize}
		\item Embedded Computers
			\begin{itemize}
				\item \textbf{Most Prevalent type of computer/computer class}
				\item Computers contained in other devices
				\item Usually a small number of predetermined applications
				\item Emphasis on cost and low power 
			\end{itemize}
		\item Personal Mobile Device
			\begin{itemize}
				\item Battery-powered wireless devices with multimedia user interfaces
				\item Smart phones and tablets
				\item Reliance on touch screens
				\item Emphasis on cost and energy efficiency 
			\end{itemize}
		\item Large Cluster/Warehouse-Scale-Computers (WSCs)
			\begin{itemize}
				\item Large collections of servers connected by a network to act as a single powerful computer
				\item Scalability and availability handled through the network 
			\end{itemize}
	\end{enumerate}

	\noindent \emph{Eight Great Architecture Ideas}
	\begin{enumerate}
		  \item Design for Moore's Law
		  \item Abstraction
		  \item Make the common case fast
		  \item Parallelism
		  \item Pipelining
		  \item Prediction
		  \item Hierachy
  		\item Improve dependability via redundancy
	\end{enumerate}

	\noindent \emph{Steps for executing a program}
	\begin{enumerate}
  		\item Input device loads the machine code from the executable
  		\item The machine code is stored in memory
  		\item Processor fetches an instruction
  		\item Control decodes the instruction
  		\item Datapath executes the instruction
  		\item If application does not complete, then go to step 3
	\end{enumerate}
	\noindent \emph{\textbf{REMEMBER:}} When executing a program, you first decode the instructions for the control, and then execute the instructions.\\

	\noindent \emph{\textbf{REMEMBER:}} QTSpim is \textbf{not} a compiler, it is an \textbf{assembler.}\\

	\noindent \emph{Formulas to remember: }\\
	\begin{center}
		$$\text{Dies per Wafer} \approx \frac{\text{Wafer Area}}{\text{Die Area}}$$
		$$\text{Yield} = \frac{1}{(1 + (\text{Defects per area})(\frac{\text{Die Area}}{2}))^2} $$
		$$\text{Cost per Die} = \frac{\text{Wafer Cost}}{(\text{Die per Wafer}) * \text{yield}}$$
		
		$$ \text{When comparing performance between } \text{Computer}_x \text{ and } \text{Computer}_y:$$
		$$ \text{Performance} = \frac{1}{\text{Execution Time}}$$
		$$ \text{Performance}_x > \text{Performance}_y $$
		$$ \frac{1}{\text{Execution Time}_x} >  \frac{1}{\text{Execution Time}_y}$$
		$$ \text{Execution Time}_y  > \text{Execution Time}_x $$

		$$ \text{Finding CPU Time: } $$
		$$ \text{CPU Time} = \text{CPU Clock Cycles} * \text{CPU Clock Cycle Time} = \frac{\text{CPU Clock Cycles}}{\text{CPU clock rate}} $$
		$$ \text{CPI} = \frac{\text{CPU Clock Cycles}}{\text{Instruction Count}} $$
		$$ \text{CPU Time} = \text{Instruction Count} * \text{CPI} * \text{CPU Clock Cycles} $$ \\

		$$ \text{Relationship between clock rate and clock speed rotation:} $$
		$$ \text{clock rate} = \frac{1}{\text{clock speed}} $$
		$$ \text{clock speed} = \frac{1}{\text{clock rate}} $$

		$$ \text{Calculate Overall Speedup} $$
		$$ \text{execution time}_{new} = \text{execution time}_{old} * (1 - \text{fraction}_{enhanced} + \frac{\text{fraction}_{enhanced}}{\text{speedup}_{enhanced}}$$
		$$ \text{speedup}_{overall} = \frac{\text{execution time}_{old}}{\text{execution time}_{new}} = \frac{1}{(1 - \text{fraction}_{enhanced}) + \frac{\text{fraction}_{enhanced}}{\text{speedup}_{enhanced}}}$$
	\end{center}

	\noindent\emph{Terms to know: }
	\begin{enumerate}
		\item \textbf{Latency Response (execution time)}: The time between the start and completion of an event or task.
		\item \textbf{Bandwidth/Throughput}: The total amount of work done in a given period of time.
		\item \textbf{Clock cycles Per Instruction (CPI)}: Average number of clock cycles per instruction for a program or process
		\item \textbf{Amdahl's Law}: The performance improvement gained from using an enhanced component is limited by the portion improved.
	\end{enumerate}

	\noindent \emph{\textbf{REMEMBER:}} The memory access bottleneck is caused by fast execution time and slower memory access time. To solve this we use \textbf{3 layers of cache}\\

	\noindent \emph{Conversions: } \\
	$ 1 \text{ Kib} \text{ (Kibibyte) } = 2^{10} \text{ bytes or } 1024 \text{ bytes}$ \\
	$ 1 \text{ Kib } = 1024 \text{ bytes } = 1.024 \text{ KB} $ \\
	\emph{For memory: } $2^n$ can store $\{0, 1, ..., 2^{n - 1}\}$ bytes. \\

	\noindent \emph{Power Issues: }\\
	\noindent \textbf{Energy} is the capacity to change an object's state. Measured in joules.\\
	\indent One joule is equal to one Newton acting through one meter.\\
	\noindent \textbf{Power} is the energy amount used over a period of time, units are Watts.\\
		\indent Watts = $\frac{joules}{second}$
		$$ \text{Power} = \frac{\text{$\Delta$ Energy}}{\text{$\Delta$ Time}} $$
	\begin{enumerate}
		\item There is a need for energy efficient Processors becuase of the \textbf{major issue of \emph{heat}}.
		\item Complementary Metal Oxide Semiconductors (CMOSs):
		\begin{enumerate}
			\item dominant technology for integrated circuits, energy consumption consists of dynamic and static energy.
			\item \textbf{Dynamic Energy:} The energy consumed by the switching of transistors from 0 to 1 or 1 to 0, this is dependent on the capacitive loading of each transistor and the voltage applied. The \textbf{Dynamic Power} is the power required per transistor
			\begin{enumerate}
				\item $\text{Energy} \propto \frac{1}{2} * \text{Capacitive load} * \text{Voltage}^2$
				\item $\text{Power} \propto \frac{1}{2} * \text{Capacitive load} * \text{Voltage}^2 * \text{Frequency switched} $
				\item $ \therefore \text{Power} \propto \text{Energy} * \text{Frequency Switched} $
			\end{enumerate}
			\item \textbf{Static Energy:} energy consumed through current leakage, this is the current that flows through a transistor even when it is off (approximately 40\% of power consumption.)
			\item \textbf{Static power:} power lost from static energy, is proportional to the number of \\ \\
		\end{enumerate}
	\end{enumerate} 

	\noindent Techniques to Improve Energy Efficiency
	\begin{enumerate}
		\item Turn off the clock for inactive modules (do nothing efficiently)
		\item Use a lower clock frequency during periods of low activity (called dynamic frequency scaling or DFS), can often allow lower voltages as well
		\item Use a low power mode for memory and storage when not being accessed
		\item Completely turn off power to subsets of the chip when not being used\\
	\end{enumerate}

	\noindent \textbf{Number Notation}
	The value of a specific numer in a specified base (radix) is calculated by: 
	$$ \sum_{i = -m}^{n - 1} \text{d}_i * \text{b}^i = \text{d}_{n - 1} * 10^{n - 1} + ... + \text{d}_{1} * 10^{1} + ... + \text{d}_{-m} * 10^{-m}$$
	where \emph{d} is a digit and \emph{b} is the base.\\
	\textbf{EXAMPLE}
	$$ 425.34_{10} = \sum_{i = -2}^{3} \text{d}_i * \text{10}^i = (4 * 10^2) + (2 * 10^1) + (5 * 10^0) + (3 * 10^{-1}) + (4 * 10^{-2}) = 400 + 20 + 5 + 0.3 + 0.04$$
	$$ 1001.01_2 = \sum_{i = -2}^{4} \text{d}_i * \text{2}^i =  (1 * 2^3) + (0 * 2 ^ 2) + (0 * 2^1) + (1 * 2^0) + (0 * 2^{-1}) + (1 * 2^{-2}) = 8 + 0 + 0 + 1 + 0 + 0.25 = 9.25 $$

	\emph{Range of values:} To find the range of numbers that can be represented by a certain base with \emph{n} digits, use the formula $M^N$ where $M=$base and $N=$number of digits.\\
	So a base 10 number with 3 decimal number values can represent $M^N = 10^3 = 1000$ numbers, the range would be $[0, 999]$. If it was base 2, then $M^N = 2^3 = 8$ or $[0, 7]$
\end{document}