\documentclass{book}
\usepackage[margin=1in,footskip=0.25in]{geometry}
\usepackage{pgf, tikz}
\usepackage{amsmath}
\usepackage{centernot}
\usepackage{pgfplots}

\usetikzlibrary{arrows, automata}

\title{CDA3100-0001: Comp Org 1}
\author{Ahmet}

\begin{document}
	\noindent Computer Organization 1\\\\
	\emph{Types of Computers}
	\begin{enumerate}
		\item Personal Computers (PCs)
			\begin{itemize}
				\item Intended for a single user at a stationary location
				\item Notebooks and workstations
				\item Emphasize good performance to single users at low cost
			\end{itemize}
		\item Servers
			\begin{itemize}
				\item Accessed by other computers to provide computation and/or data
				\item Typically only accessed via a network
				\item Greater computing, storage, and I/O capacity
				\item Emphasis on performing well under large workloads with enhanced dependability
			\end{itemize}
		\item Embedded Computers
			\begin{itemize}
				\item \textbf{Most Prevalent type of computer/computer class}
				\item Computers contained in other devices
				\item Usually a small number of predetermined applications
				\item Emphasis on cost and low power 
			\end{itemize}
		\item Personal Mobile Device
			\begin{itemize}
				\item Battery-powered wireless devices with multimedia user interfaces
				\item Smart phones and tablets
				\item Reliance on touch screens
				\item Emphasis on cost and energy efficiency 
			\end{itemize}
		\item Large Cluster/Warehouse-Scale-Computers (WSCs)
			\begin{itemize}
				\item Large collections of servers connected by a network to act as a single powerful computer
				\item Scalability and availability handled through the network 
			\end{itemize}
	\end{enumerate}

	\noindent \emph{Eight Great Architecture Ideas}
	\begin{enumerate}
		  \item Design for Moore's Law
		  \item Abstraction
		  \item Make the common case fast
		  \item Parallelism
		  \item Pipelining
		  \item Prediction
		  \item Hierachy
  		\item Improve dependability via redundancy
	\end{enumerate}

	\noindent \emph{Steps for executing a program}
	\begin{enumerate}
  		\item Input device loads the machine code from the executable
  		\item The machine code is stored in memory
  		\item Processor fetches an instruction
  		\item Control decodes the instruction
  		\item Datapath executes the instruction
  		\item If application does not complete, then go to step 3
	\end{enumerate}

	\noindent \emph{Remember: }QTSpim is \textbf{not} a compiler, it is an \textbf{assembler.}\\

	\noindent \emph{Formulas to remember: }\\
	\begin{center}
		$$\text{Dies per Wafer} \approx \frac{\text{Wafer Area}}{\text{Die Area}}$$
		$$\text{Yield} = \frac{1}{(1 + (\text{Defects per area})(\frac{\text{Die Area}}{2}))^2} $$
		$$\text{Cost per Die} = \frac{\text{Wafer Cost}}{(\text{Die per Wafer}) * \text{yield}}$$
		
		$$ \text{When comparing performance between } \text{Computer}_x \text{ and } \text{Computer}_y:$$
		$$ \text{Performance} = \frac{1}{\text{Execution Time}}$$
		$$ \text{Performance}_x > \text{Performance}_y $$
		$$ \frac{1}{\text{Execution Time}_x} >  \frac{1}{\text{Execution Time}_y}$$
		$$ \text{Execution Time}_y  > \text{Execution Time}_x $$

		$$ \text{Finding CPU Time: } $$
		$$ \text{CPU Time} = \text{CPU Clock Cycles} * \text{CPU Clock Cycle Time} = \frac{\text{CPU Clock Cycles}}{\text{CPU clock rate}} $$
		$$ \text{CPI} = \frac{\text{CPU Clock Cycles}}{\text{Instruction Count}} $$
		$$ \text{CPU Time} = \text{Instruction Count} * \text{CPI} * \text{CPU Clock Cycles} $$ \\
	\end{center}

	\noindent\emph{Terms to know: }
	\begin{enumerate}
		\item Latency (Response, or execution time): The time between the start and completion of an event or task.
		\item Bandwidth/Throughput: The total amount of work done in a given period of time.
		\item Clock cycles Per Instruction (CPI): Average number of clock cycles per instruction for a program or process
		\item Amdahl's Law: The performance improvement gained from using an enhanced component is limited by the portion improved.
	\end{enumerate}
\end{document}